// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2017 The go-ovh Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VpsIP Information about an IP address for a VPS Virtual Machine
// swagger:model vps.Ip
type VpsIP struct {

	// gateway
	// Read Only: true
	Gateway string `json:"gateway,omitempty"`

	// geolocation
	// Required: true
	// Read Only: true
	Geolocation string `json:"geolocation"`

	// The effective ip address of the Ip object
	// Required: true
	// Read Only: true
	IPAddress string `json:"ipAddress"`

	// mac address
	// Read Only: true
	MacAddress string `json:"macAddress,omitempty"`

	// reverse
	Reverse string `json:"reverse,omitempty"`

	// type
	// Required: true
	// Read Only: true
	Type string `json:"type"`

	// version
	// Required: true
	// Read Only: true
	Version string `json:"version"`
}

// Validate validates this vps Ip
func (m *VpsIP) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGeolocation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIPAddress(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var vpsIpTypeGeolocationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["au","be","ca","cz","de","es","fi","fr","ie","it","lt","nl","pl","pt","sg","uk","us"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vpsIpTypeGeolocationPropEnum = append(vpsIpTypeGeolocationPropEnum, v)
	}
}

const (
	// VpsIPGeolocationAu captures enum value "au"
	VpsIPGeolocationAu string = "au"
	// VpsIPGeolocationBe captures enum value "be"
	VpsIPGeolocationBe string = "be"
	// VpsIPGeolocationCa captures enum value "ca"
	VpsIPGeolocationCa string = "ca"
	// VpsIPGeolocationCz captures enum value "cz"
	VpsIPGeolocationCz string = "cz"
	// VpsIPGeolocationDe captures enum value "de"
	VpsIPGeolocationDe string = "de"
	// VpsIPGeolocationEs captures enum value "es"
	VpsIPGeolocationEs string = "es"
	// VpsIPGeolocationFi captures enum value "fi"
	VpsIPGeolocationFi string = "fi"
	// VpsIPGeolocationFr captures enum value "fr"
	VpsIPGeolocationFr string = "fr"
	// VpsIPGeolocationIe captures enum value "ie"
	VpsIPGeolocationIe string = "ie"
	// VpsIPGeolocationIt captures enum value "it"
	VpsIPGeolocationIt string = "it"
	// VpsIPGeolocationLt captures enum value "lt"
	VpsIPGeolocationLt string = "lt"
	// VpsIPGeolocationNl captures enum value "nl"
	VpsIPGeolocationNl string = "nl"
	// VpsIPGeolocationPl captures enum value "pl"
	VpsIPGeolocationPl string = "pl"
	// VpsIPGeolocationPt captures enum value "pt"
	VpsIPGeolocationPt string = "pt"
	// VpsIPGeolocationSg captures enum value "sg"
	VpsIPGeolocationSg string = "sg"
	// VpsIPGeolocationUk captures enum value "uk"
	VpsIPGeolocationUk string = "uk"
	// VpsIPGeolocationUs captures enum value "us"
	VpsIPGeolocationUs string = "us"
)

// prop value enum
func (m *VpsIP) validateGeolocationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, vpsIpTypeGeolocationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VpsIP) validateGeolocation(formats strfmt.Registry) error {

	if err := validate.RequiredString("geolocation", "body", string(m.Geolocation)); err != nil {
		return err
	}

	// value enum
	if err := m.validateGeolocationEnum("geolocation", "body", m.Geolocation); err != nil {
		return err
	}

	return nil
}

func (m *VpsIP) validateIPAddress(formats strfmt.Registry) error {

	if err := validate.RequiredString("ipAddress", "body", string(m.IPAddress)); err != nil {
		return err
	}

	return nil
}

var vpsIpTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["additional","primary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vpsIpTypeTypePropEnum = append(vpsIpTypeTypePropEnum, v)
	}
}

const (
	// VpsIPTypeAdditional captures enum value "additional"
	VpsIPTypeAdditional string = "additional"
	// VpsIPTypePrimary captures enum value "primary"
	VpsIPTypePrimary string = "primary"
)

// prop value enum
func (m *VpsIP) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, vpsIpTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VpsIP) validateType(formats strfmt.Registry) error {

	if err := validate.RequiredString("type", "body", string(m.Type)); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

var vpsIpTypeVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["v4","v6"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vpsIpTypeVersionPropEnum = append(vpsIpTypeVersionPropEnum, v)
	}
}

const (
	// VpsIPVersionV4 captures enum value "v4"
	VpsIPVersionV4 string = "v4"
	// VpsIPVersionV6 captures enum value "v6"
	VpsIPVersionV6 string = "v6"
)

// prop value enum
func (m *VpsIP) validateVersionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, vpsIpTypeVersionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VpsIP) validateVersion(formats strfmt.Registry) error {

	if err := validate.RequiredString("version", "body", string(m.Version)); err != nil {
		return err
	}

	// value enum
	if err := m.validateVersionEnum("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *VpsIP) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VpsIP) UnmarshalBinary(b []byte) error {
	var res VpsIP
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
