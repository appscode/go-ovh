// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2017 The go-ovh Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DedicatedInstallationTemplateTemplates Available installation templates
// swagger:model dedicated.InstallationTemplate.Templates
type DedicatedInstallationTemplateTemplates struct {

	// list of all language available for this template
	// Required: true
	// Read Only: true
	AvailableLanguages []string `json:"availableLanguages"`

	// This distribution is new, and although tested and functional, may still display odd behaviour
	// Read Only: true
	Beta *bool `json:"beta,omitempty"`

	// this template  bit format
	// Required: true
	// Read Only: true
	BitFormat int64 `json:"bitFormat"`

	// category of this template (informative only)
	// Required: true
	// Read Only: true
	Category string `json:"category"`

	// customization
	Customization *DedicatedTemplateOsProperties `json:"customization,omitempty"`

	// the default language of this template
	DefaultLanguage string `json:"defaultLanguage,omitempty"`

	// is this distribution deprecated
	// Read Only: true
	Deprecated *bool `json:"deprecated,omitempty"`

	// information about this template
	// Required: true
	// Read Only: true
	Description string `json:"description"`

	// the distribution this template is based on
	// Required: true
	// Read Only: true
	Distribution string `json:"distribution"`

	// this template family type
	// Required: true
	// Read Only: true
	Family string `json:"family"`

	// list of all filesystems  available for this template
	// Required: true
	// Read Only: true
	Filesystems []string `json:"filesystems"`

	// This distribution supports hardware raid configuration through the OVH API
	// Read Only: true
	HardRaidConfiguration *bool `json:"hardRaidConfiguration,omitempty"`

	// Date of last modification of the base image
	// Read Only: true
	LastModification strfmt.DateTime `json:"lastModification,omitempty"`

	// This distribution supports Logical Volumes (Linux LVM)
	// Read Only: true
	LvmReady *bool `json:"lvmReady,omitempty"`

	// This distribution supports installation using the distribution's native kernel instead of the recommended OVH kernel
	// Read Only: true
	SupportsDistributionKernel *bool `json:"supportsDistributionKernel,omitempty"`

	// This distribution supports the GUID Partition Table (GPT), providing up to 128 partitions that can have more than 2 TB
	// Read Only: true
	SupportsGptLabel *bool `json:"supportsGptLabel,omitempty"`

	// This distribution supports RTM software
	// Required: true
	// Read Only: true
	SupportsRTM bool `json:"supportsRTM"`

	// This distribution supports the microsoft SQL server
	// Read Only: true
	SupportsSQLServer *bool `json:"supportsSqlServer,omitempty"`

	// This distribution supports UEFI setup
	// Read Only: true
	SupportsUEFI string `json:"supportsUEFI,omitempty"`

	// This template name
	TemplateName string `json:"templateName,omitempty"`
}

// Validate validates this dedicated installation template templates
func (m *DedicatedInstallationTemplateTemplates) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailableLanguages(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBitFormat(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCategory(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCustomization(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDefaultLanguage(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDistribution(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFamily(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFilesystems(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSupportsRTM(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSupportsUEFI(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var dedicatedInstallationTemplateTemplatesAvailableLanguagesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","bg","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","it","ja","ko","lt","lv","nb","nl","no","pl","pt","ro","ru","sk","sl","sr","sv","th","tr","tu","uk","zh-Hans-CN","zh-Hans-HK"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesAvailableLanguagesItemsEnum = append(dedicatedInstallationTemplateTemplatesAvailableLanguagesItemsEnum, v)
	}
}

func (m *DedicatedInstallationTemplateTemplates) validateAvailableLanguagesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesAvailableLanguagesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateAvailableLanguages(formats strfmt.Registry) error {

	if err := validate.Required("availableLanguages", "body", m.AvailableLanguages); err != nil {
		return err
	}

	for i := 0; i < len(m.AvailableLanguages); i++ {

		// value enum
		if err := m.validateAvailableLanguagesItemsEnum("availableLanguages"+"."+strconv.Itoa(i), "body", m.AvailableLanguages[i]); err != nil {
			return err
		}

	}

	return nil
}

var dedicatedInstallationTemplateTemplatesTypeBitFormatPropEnum []interface{}

func init() {
	var res []int64
	if err := json.Unmarshal([]byte(`[32,64]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesTypeBitFormatPropEnum = append(dedicatedInstallationTemplateTemplatesTypeBitFormatPropEnum, v)
	}
}

// prop value enum
func (m *DedicatedInstallationTemplateTemplates) validateBitFormatEnum(path, location string, value int64) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesTypeBitFormatPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateBitFormat(formats strfmt.Registry) error {

	if err := validate.Required("bitFormat", "body", int64(m.BitFormat)); err != nil {
		return err
	}

	// value enum
	if err := m.validateBitFormatEnum("bitFormat", "body", m.BitFormat); err != nil {
		return err
	}

	return nil
}

var dedicatedInstallationTemplateTemplatesTypeCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["basic","customer","hosting","other","readyToUse","virtualisation"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesTypeCategoryPropEnum = append(dedicatedInstallationTemplateTemplatesTypeCategoryPropEnum, v)
	}
}

const (
	// DedicatedInstallationTemplateTemplatesCategoryBasic captures enum value "basic"
	DedicatedInstallationTemplateTemplatesCategoryBasic string = "basic"
	// DedicatedInstallationTemplateTemplatesCategoryCustomer captures enum value "customer"
	DedicatedInstallationTemplateTemplatesCategoryCustomer string = "customer"
	// DedicatedInstallationTemplateTemplatesCategoryHosting captures enum value "hosting"
	DedicatedInstallationTemplateTemplatesCategoryHosting string = "hosting"
	// DedicatedInstallationTemplateTemplatesCategoryOther captures enum value "other"
	DedicatedInstallationTemplateTemplatesCategoryOther string = "other"
	// DedicatedInstallationTemplateTemplatesCategoryReadyToUse captures enum value "readyToUse"
	DedicatedInstallationTemplateTemplatesCategoryReadyToUse string = "readyToUse"
	// DedicatedInstallationTemplateTemplatesCategoryVirtualisation captures enum value "virtualisation"
	DedicatedInstallationTemplateTemplatesCategoryVirtualisation string = "virtualisation"
)

// prop value enum
func (m *DedicatedInstallationTemplateTemplates) validateCategoryEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesTypeCategoryPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateCategory(formats strfmt.Registry) error {

	if err := validate.RequiredString("category", "body", string(m.Category)); err != nil {
		return err
	}

	// value enum
	if err := m.validateCategoryEnum("category", "body", m.Category); err != nil {
		return err
	}

	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateCustomization(formats strfmt.Registry) error {

	if swag.IsZero(m.Customization) { // not required
		return nil
	}

	if m.Customization != nil {

		if err := m.Customization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customization")
			}
			return err
		}
	}

	return nil
}

var dedicatedInstallationTemplateTemplatesTypeDefaultLanguagePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ar","bg","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","it","ja","ko","lt","lv","nb","nl","no","pl","pt","ro","ru","sk","sl","sr","sv","th","tr","tu","uk","zh-Hans-CN","zh-Hans-HK"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesTypeDefaultLanguagePropEnum = append(dedicatedInstallationTemplateTemplatesTypeDefaultLanguagePropEnum, v)
	}
}

const (
	// DedicatedInstallationTemplateTemplatesDefaultLanguageAr captures enum value "ar"
	DedicatedInstallationTemplateTemplatesDefaultLanguageAr string = "ar"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageBg captures enum value "bg"
	DedicatedInstallationTemplateTemplatesDefaultLanguageBg string = "bg"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageCs captures enum value "cs"
	DedicatedInstallationTemplateTemplatesDefaultLanguageCs string = "cs"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageDa captures enum value "da"
	DedicatedInstallationTemplateTemplatesDefaultLanguageDa string = "da"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageDe captures enum value "de"
	DedicatedInstallationTemplateTemplatesDefaultLanguageDe string = "de"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageEl captures enum value "el"
	DedicatedInstallationTemplateTemplatesDefaultLanguageEl string = "el"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageEn captures enum value "en"
	DedicatedInstallationTemplateTemplatesDefaultLanguageEn string = "en"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageEs captures enum value "es"
	DedicatedInstallationTemplateTemplatesDefaultLanguageEs string = "es"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageEt captures enum value "et"
	DedicatedInstallationTemplateTemplatesDefaultLanguageEt string = "et"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageFi captures enum value "fi"
	DedicatedInstallationTemplateTemplatesDefaultLanguageFi string = "fi"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageFr captures enum value "fr"
	DedicatedInstallationTemplateTemplatesDefaultLanguageFr string = "fr"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageHe captures enum value "he"
	DedicatedInstallationTemplateTemplatesDefaultLanguageHe string = "he"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageHr captures enum value "hr"
	DedicatedInstallationTemplateTemplatesDefaultLanguageHr string = "hr"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageHu captures enum value "hu"
	DedicatedInstallationTemplateTemplatesDefaultLanguageHu string = "hu"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageIt captures enum value "it"
	DedicatedInstallationTemplateTemplatesDefaultLanguageIt string = "it"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageJa captures enum value "ja"
	DedicatedInstallationTemplateTemplatesDefaultLanguageJa string = "ja"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageKo captures enum value "ko"
	DedicatedInstallationTemplateTemplatesDefaultLanguageKo string = "ko"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageLt captures enum value "lt"
	DedicatedInstallationTemplateTemplatesDefaultLanguageLt string = "lt"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageLv captures enum value "lv"
	DedicatedInstallationTemplateTemplatesDefaultLanguageLv string = "lv"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageNb captures enum value "nb"
	DedicatedInstallationTemplateTemplatesDefaultLanguageNb string = "nb"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageNl captures enum value "nl"
	DedicatedInstallationTemplateTemplatesDefaultLanguageNl string = "nl"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageNo captures enum value "no"
	DedicatedInstallationTemplateTemplatesDefaultLanguageNo string = "no"
	// DedicatedInstallationTemplateTemplatesDefaultLanguagePl captures enum value "pl"
	DedicatedInstallationTemplateTemplatesDefaultLanguagePl string = "pl"
	// DedicatedInstallationTemplateTemplatesDefaultLanguagePt captures enum value "pt"
	DedicatedInstallationTemplateTemplatesDefaultLanguagePt string = "pt"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageRo captures enum value "ro"
	DedicatedInstallationTemplateTemplatesDefaultLanguageRo string = "ro"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageRu captures enum value "ru"
	DedicatedInstallationTemplateTemplatesDefaultLanguageRu string = "ru"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageSk captures enum value "sk"
	DedicatedInstallationTemplateTemplatesDefaultLanguageSk string = "sk"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageSl captures enum value "sl"
	DedicatedInstallationTemplateTemplatesDefaultLanguageSl string = "sl"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageSr captures enum value "sr"
	DedicatedInstallationTemplateTemplatesDefaultLanguageSr string = "sr"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageSv captures enum value "sv"
	DedicatedInstallationTemplateTemplatesDefaultLanguageSv string = "sv"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageTh captures enum value "th"
	DedicatedInstallationTemplateTemplatesDefaultLanguageTh string = "th"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageTr captures enum value "tr"
	DedicatedInstallationTemplateTemplatesDefaultLanguageTr string = "tr"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageTu captures enum value "tu"
	DedicatedInstallationTemplateTemplatesDefaultLanguageTu string = "tu"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageUk captures enum value "uk"
	DedicatedInstallationTemplateTemplatesDefaultLanguageUk string = "uk"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageZhHansCN captures enum value "zh-Hans-CN"
	DedicatedInstallationTemplateTemplatesDefaultLanguageZhHansCN string = "zh-Hans-CN"
	// DedicatedInstallationTemplateTemplatesDefaultLanguageZhHansHK captures enum value "zh-Hans-HK"
	DedicatedInstallationTemplateTemplatesDefaultLanguageZhHansHK string = "zh-Hans-HK"
)

// prop value enum
func (m *DedicatedInstallationTemplateTemplates) validateDefaultLanguageEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesTypeDefaultLanguagePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateDefaultLanguage(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultLanguage) { // not required
		return nil
	}

	// value enum
	if err := m.validateDefaultLanguageEnum("defaultLanguage", "body", m.DefaultLanguage); err != nil {
		return err
	}

	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateDescription(formats strfmt.Registry) error {

	if err := validate.RequiredString("description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateDistribution(formats strfmt.Registry) error {

	if err := validate.RequiredString("distribution", "body", string(m.Distribution)); err != nil {
		return err
	}

	return nil
}

var dedicatedInstallationTemplateTemplatesTypeFamilyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["bsd","linux","solaris","windows"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesTypeFamilyPropEnum = append(dedicatedInstallationTemplateTemplatesTypeFamilyPropEnum, v)
	}
}

const (
	// DedicatedInstallationTemplateTemplatesFamilyBsd captures enum value "bsd"
	DedicatedInstallationTemplateTemplatesFamilyBsd string = "bsd"
	// DedicatedInstallationTemplateTemplatesFamilyLinux captures enum value "linux"
	DedicatedInstallationTemplateTemplatesFamilyLinux string = "linux"
	// DedicatedInstallationTemplateTemplatesFamilySolaris captures enum value "solaris"
	DedicatedInstallationTemplateTemplatesFamilySolaris string = "solaris"
	// DedicatedInstallationTemplateTemplatesFamilyWindows captures enum value "windows"
	DedicatedInstallationTemplateTemplatesFamilyWindows string = "windows"
)

// prop value enum
func (m *DedicatedInstallationTemplateTemplates) validateFamilyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesTypeFamilyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateFamily(formats strfmt.Registry) error {

	if err := validate.RequiredString("family", "body", string(m.Family)); err != nil {
		return err
	}

	// value enum
	if err := m.validateFamilyEnum("family", "body", m.Family); err != nil {
		return err
	}

	return nil
}

var dedicatedInstallationTemplateTemplatesFilesystemsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["btrfs","ext3","ext4","ntfs","reiserfs","swap","ufs","xfs","zfs"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesFilesystemsItemsEnum = append(dedicatedInstallationTemplateTemplatesFilesystemsItemsEnum, v)
	}
}

func (m *DedicatedInstallationTemplateTemplates) validateFilesystemsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesFilesystemsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateFilesystems(formats strfmt.Registry) error {

	if err := validate.Required("filesystems", "body", m.Filesystems); err != nil {
		return err
	}

	for i := 0; i < len(m.Filesystems); i++ {

		// value enum
		if err := m.validateFilesystemsItemsEnum("filesystems"+"."+strconv.Itoa(i), "body", m.Filesystems[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateSupportsRTM(formats strfmt.Registry) error {

	if err := validate.Required("supportsRTM", "body", bool(m.SupportsRTM)); err != nil {
		return err
	}

	return nil
}

var dedicatedInstallationTemplateTemplatesTypeSupportsUEFIPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no","only","yes"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dedicatedInstallationTemplateTemplatesTypeSupportsUEFIPropEnum = append(dedicatedInstallationTemplateTemplatesTypeSupportsUEFIPropEnum, v)
	}
}

const (
	// DedicatedInstallationTemplateTemplatesSupportsUEFINo captures enum value "no"
	DedicatedInstallationTemplateTemplatesSupportsUEFINo string = "no"
	// DedicatedInstallationTemplateTemplatesSupportsUEFIOnly captures enum value "only"
	DedicatedInstallationTemplateTemplatesSupportsUEFIOnly string = "only"
	// DedicatedInstallationTemplateTemplatesSupportsUEFIYes captures enum value "yes"
	DedicatedInstallationTemplateTemplatesSupportsUEFIYes string = "yes"
)

// prop value enum
func (m *DedicatedInstallationTemplateTemplates) validateSupportsUEFIEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, dedicatedInstallationTemplateTemplatesTypeSupportsUEFIPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DedicatedInstallationTemplateTemplates) validateSupportsUEFI(formats strfmt.Registry) error {

	if swag.IsZero(m.SupportsUEFI) { // not required
		return nil
	}

	// value enum
	if err := m.validateSupportsUEFIEnum("supportsUEFI", "body", m.SupportsUEFI); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DedicatedInstallationTemplateTemplates) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DedicatedInstallationTemplateTemplates) UnmarshalBinary(b []byte) error {
	var res DedicatedInstallationTemplateTemplates
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
