// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2017 The go-ovh Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IPLBBackendProbe Probe used to determine if a backend is alive and can handle requests
// swagger:model iplb.BackendProbe
type IPLBBackendProbe struct {

	// Force probe to run over a SSL layer. Defaults to false
	ForceSsl bool `json:"forceSsl,omitempty"`

	// Seconds between each probe check. Must be > 30sec. Defaults to 30
	Interval int64 `json:"interval,omitempty"`

	// Matcher to use to valide "expect". "default" uses HAProxy's default behavior for this type of check. "status" is only supported for HTTP probes
	Match string `json:"match,omitempty"`

	// HTTP method to use with "http" probe. Consider using HEAD to save bandwidth when possible. Defaults to "GET"
	Method string `json:"method,omitempty"`

	// Invert the matching operator effect
	Negate bool `json:"negate,omitempty"`

	// Server response expected when UP. Empty for "default", comma delimited list of statuses for "status", string for "contains", regex for "matches"
	Pattern string `json:"pattern,omitempty"`

	// Port used to probe your backend. Equal to farm port if null. Ignored for oco probe type
	Port int64 `json:"port,omitempty"`

	// Probe type. "tcp" if null
	Type string `json:"type,omitempty"`

	// URL to use for HTTP probes of the form [www.example.com]/path/to/check. Protocol will be ignored. Defaults to "/"
	URL string `json:"url,omitempty"`
}

// Validate validates this iplb backend probe
func (m *IPLBBackendProbe) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMatch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var iplbBackendProbeTypeMatchPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["contains","default","internal","matches","status"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iplbBackendProbeTypeMatchPropEnum = append(iplbBackendProbeTypeMatchPropEnum, v)
	}
}

const (
	// IPLBBackendProbeMatchContains captures enum value "contains"
	IPLBBackendProbeMatchContains string = "contains"
	// IPLBBackendProbeMatchDefault captures enum value "default"
	IPLBBackendProbeMatchDefault string = "default"
	// IPLBBackendProbeMatchInternal captures enum value "internal"
	IPLBBackendProbeMatchInternal string = "internal"
	// IPLBBackendProbeMatchMatches captures enum value "matches"
	IPLBBackendProbeMatchMatches string = "matches"
	// IPLBBackendProbeMatchStatus captures enum value "status"
	IPLBBackendProbeMatchStatus string = "status"
)

// prop value enum
func (m *IPLBBackendProbe) validateMatchEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iplbBackendProbeTypeMatchPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *IPLBBackendProbe) validateMatch(formats strfmt.Registry) error {

	if swag.IsZero(m.Match) { // not required
		return nil
	}

	// value enum
	if err := m.validateMatchEnum("match", "body", m.Match); err != nil {
		return err
	}

	return nil
}

var iplbBackendProbeTypeMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GET","HEAD","OPTIONS","internal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iplbBackendProbeTypeMethodPropEnum = append(iplbBackendProbeTypeMethodPropEnum, v)
	}
}

const (
	// IPLBBackendProbeMethodGET captures enum value "GET"
	IPLBBackendProbeMethodGET string = "GET"
	// IPLBBackendProbeMethodHEAD captures enum value "HEAD"
	IPLBBackendProbeMethodHEAD string = "HEAD"
	// IPLBBackendProbeMethodOPTIONS captures enum value "OPTIONS"
	IPLBBackendProbeMethodOPTIONS string = "OPTIONS"
	// IPLBBackendProbeMethodInternal captures enum value "internal"
	IPLBBackendProbeMethodInternal string = "internal"
)

// prop value enum
func (m *IPLBBackendProbe) validateMethodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iplbBackendProbeTypeMethodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *IPLBBackendProbe) validateMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.Method) { // not required
		return nil
	}

	// value enum
	if err := m.validateMethodEnum("method", "body", m.Method); err != nil {
		return err
	}

	return nil
}

var iplbBackendProbeTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["http","internal","mysql","oco","pgsql","smtp","tcp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		iplbBackendProbeTypeTypePropEnum = append(iplbBackendProbeTypeTypePropEnum, v)
	}
}

const (
	// IPLBBackendProbeTypeHTTP captures enum value "http"
	IPLBBackendProbeTypeHTTP string = "http"
	// IPLBBackendProbeTypeInternal captures enum value "internal"
	IPLBBackendProbeTypeInternal string = "internal"
	// IPLBBackendProbeTypeMysql captures enum value "mysql"
	IPLBBackendProbeTypeMysql string = "mysql"
	// IPLBBackendProbeTypeOco captures enum value "oco"
	IPLBBackendProbeTypeOco string = "oco"
	// IPLBBackendProbeTypePgsql captures enum value "pgsql"
	IPLBBackendProbeTypePgsql string = "pgsql"
	// IPLBBackendProbeTypeSMTP captures enum value "smtp"
	IPLBBackendProbeTypeSMTP string = "smtp"
	// IPLBBackendProbeTypeTCP captures enum value "tcp"
	IPLBBackendProbeTypeTCP string = "tcp"
)

// prop value enum
func (m *IPLBBackendProbe) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, iplbBackendProbeTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *IPLBBackendProbe) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IPLBBackendProbe) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IPLBBackendProbe) UnmarshalBinary(b []byte) error {
	var res IPLBBackendProbe
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
